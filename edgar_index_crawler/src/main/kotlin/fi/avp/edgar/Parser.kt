package fi.avp.edgar

import fi.avp.edgar.data.ReportRecord
import fi.avp.util.Locations
import fi.avp.util.companyQuarterlyReport
import fi.avp.util.preparePerCompanyReportStorageStructure
import org.w3c.dom.Document
import org.w3c.dom.Node
import org.w3c.dom.NodeList
import java.io.InputStream
import java.nio.file.Files
import java.time.Duration
import java.time.LocalDate
import java.time.ZoneOffset
import javax.xml.namespace.NamespaceContext
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.xpath.XPathConstants
import javax.xml.xpath.XPathFactory

data class ReportData(val assets: Int)

fun main(args: Array<String>) {
    val targetSample =
        Locations.xbrlDir.resolve("amazon_com_inc/2020/QTR2/amazon_com_inc-10-Q-QTR2-2020-05-010001018724-20-000010-xbrl/amzn-20200331x10q.htm")
            .toFile()

    val reports = preparePerCompanyReportStorageStructure();
    reports.filterKeys { it.name == "apple_inc" }.forEach { (company, annualData) ->
        annualData.forEach { (year, reports)  ->
            reports.values.flatten()
                .sortedBy { it.date.toInstant(ZoneOffset.UTC).toEpochMilli() }
                .filter { it.reportType == "10-K" }
                .forEach { reportRecord ->
                    val companyQuarterlyReport = companyQuarterlyReport(reportRecord)
                    companyQuarterlyReport?.let {
                        val isInlineXbrl = it.fileName.toString().endsWith(".htm")
//                        println(companyQuarterlyReport)
                        XbrlParser(Files.newInputStream(it), reportRecord, isInlineXbrl).parseReport(reportRecord)
//                        println()
//                        println()
                    }
            }
        }
    }
}


class XbrlParser(val content: InputStream, val reportRecord: ReportRecord, val isInlineXbrl: Boolean = false) {

    class NamespaceCtx(val usGaapNamespaceUri: String): NamespaceContext {
        override fun getNamespaceURI(prefix: String?): String {
            return when (prefix) {
                "us-gaap" -> usGaapNamespaceUri
                else -> "http://www.xbrl.org/2003/instance"
            }
        }

        override fun getPrefix(namespaceURI: String?): String? {
            return null
        }

        override fun getPrefixes(namespaceURI: String?): MutableIterator<Any?> {
            return object : MutableIterator<Any?> {
                override fun hasNext() = false

                override fun next(): Any? = null

                override fun remove() {}
            }
        }
    }

    val xpath = XPathFactory.newInstance().newXPath();

    val parsedXml: Document by lazy {
        val documentBuilderFactory = DocumentBuilderFactory.newInstance()
        documentBuilderFactory.isNamespaceAware = true
        val documentBuilder = documentBuilderFactory.newDocumentBuilder()
        val document = documentBuilder.parse(content)
        document

    }

    init {
        xpath.namespaceContext = NamespaceCtx(parsedXml.lookupNamespaceURI("us-gaap"))
    }


    fun resolveAttrNodes(attrId: String): NodeList {
        return if (isInlineXbrl) {
            xpath.compile("//*[@name ='$attrId']").evaluate(parsedXml, XPathConstants.NODESET) as NodeList
        } else {
            xpath.compile("//$attrId").evaluate(parsedXml, XPathConstants.NODESET) as NodeList
        }
    }

    fun parseReport(reportRecord: ReportRecord) {
        val netCashBlaBla = resolveAttrNodes("us-gaap:NetCashProvidedByUsedInOperatingActivities");

        val totalAssets =
//            attributeValuesToContext("us-gaap:Assets")
            attributeValuesToContext("us-gaap:RevenueFromContractWithCustomerExcludingAssessedTax")
                .filter { it.second?.segment == null }
                .groupBy {(_, context) ->
                    Duration.between(context?.endDate?.atStartOfDay() ?: LocalDate.MAX.atStartOfDay(), reportRecord.date)
                }.minBy { it.key }
        println(totalAssets?.value)
//        printAll("Total shareholdersâ€™ equity", resolveAttr("us-gaap:StockholdersEquity"))
//        printAll("Net income", resolveAttr("us-gaap:NetIncomeLoss"))
//        printAll("Total net sales", resolveAttr("us-gaap:RevenueFromContractWithCustomerExcludingAssessedTax"))
//        printAll("netCash", netCashBlaBla)
//        printAll("Cash generated by/(used in) investing activities", resolveAttr("us-gaap:NetCashProvidedByUsedInInvestingActivities"))
    }

    data class Context(val id: String, val startDate: LocalDate, val endDate: LocalDate, val isInstant: Boolean = false, val segment: String? = null) {
        val Duration: Long
            get() = java.time.Duration.between(startDate.atStartOfDay(), endDate.atStartOfDay()).toDays()


    }


    private fun attributeValuesToContext(attrId: String): List<Pair<String, Context?>> {
        val nodes: NodeList = resolveAttrNodes(attrId)
        return List(nodes.length) {
            val contextId = nodes.item(it).attributes.getNamedItem("contextRef").textContent
            nodes.item(it).textContent to contextById(contextId)
        }
    }


    fun contextById(id: String): Context? {
        val ctxNode = xpath.compile("//*[local-name()='context' and @id='$id']").evaluate(parsedXml, XPathConstants.NODE) as Node?
        val period = ctxNode?.find("period")
        val segment = ctxNode?.find("entity")?.find("segment")?.textContent

        return period?.let {
            val instant = period.find("instant")
            val startDate = period.find("startDate") ?: instant
            val endDate = period.find("endDate") ?: instant

            Context(id, LocalDate.parse(startDate?.textContent), LocalDate.parse(endDate?.textContent), instant != null, segment)
        }
    }

    fun Node.find(name: String): Node? {
        for (i in 0..childNodes.length) {
            val node = childNodes.item(i)
            if (node?.localName == name) {
                return node
            }
        }
        return null;
    }
}
